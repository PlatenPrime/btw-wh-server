# Модуль Segs

## Описание модуля

Модуль `segs` решает задачи управления сегментами склада. Сегменты являются промежуточным уровнем между блоками и зонами, позволяя группировать зоны в логические единицы и обеспечивая расчет секторов для организации пространства склада. Модуль обеспечивает создание и управление сегментами, их привязку к блокам и зонам, а также автоматический расчет секторов на основе позиций блоков и сегментов.

## Сущности модуля

### Seg (Сегмент)

Сегмент представляет собой логическую группу зон внутри блока. Это реальная организационная единица склада, которая объединяет несколько зон для удобства управления и расчета секторов. Сегмент принадлежит одному блоку, имеет порядковый номер определяющий его позицию в блоке, рассчитанный сектор на основе позиций блока и сегмента, а также массив зон которые в него входят.

## Связи между сущностями

- **Seg → Block**: Многие к одному. Каждый сегмент принадлежит одному блоку. Связь осуществляется через поле block (ObjectId) и кэшированные данные блока в поле blockData.

- **Seg → Zone**: Один ко многим. Каждый сегмент может содержать множество зон. Связь осуществляется через массив зон в поле zones сегмента, где хранятся кэшированные данные зон (ObjectId и название). Зоны также имеют обратную связь через поле seg.

## Концепции и принятые решения

### Промежуточный уровень между блоками и зонами

Сегменты служат промежуточным уровнем между блоками и зонами. Это позволяет группировать зоны в логические единицы и обеспечивает гибкость в организации пространства склада. Без сегментов пришлось бы напрямую связывать зоны с блоками, что усложнило бы структуру и расчет секторов.

### Расчет секторов

Сектор сегмента рассчитывается по формуле: `sector = blockOrder * 1000 + segOrder`. Все зоны в сегменте получают одинаковый сектор, равный сектору сегмента. Это позволяет эффективно группировать зоны и упрощает навигацию по складу. Множитель 1000 обеспечивает разделение секторов между блоками.

### Кэширование данных

Данные блока (blockData) и зон (zones) кэшируются в сегменте. Это позволяет избежать дополнительных запросов к базе данных при работе с сегментами и обеспечивает целостность данных даже если блок или зоны изменятся после создания сегмента.

### Порядок сегментов

Каждый сегмент имеет поле order, которое определяет его позицию внутри блока. Порядок используется для расчета секторов и должен быть уникальным в рамках блока. Порядок начинается с 1, а не с 0.

### Минимальное количество зон

Каждый сегмент должен содержать минимум одну зону. Это обеспечивает целостность данных и гарантирует что сегмент имеет смысл как организационная единица.

### Уникальность зон

Каждая зона может принадлежать только одному сегменту. Это предотвращает конфликты при расчете секторов и обеспечивает четкую структуру склада.

### Массовые операции

Модуль поддерживает массовую операцию upsert для синхронизации списка сегментов. Операция выполняется в рамках MongoDB транзакции для обеспечения целостности данных между блоками, сегментами и зонами.

### Пересчет секторов

Пересчет секторов зон не происходит автоматически при изменении порядка сегментов. Пересчет выполняется явно через эндпоинт `/api/blocks/recalculate-zones-sectors` после завершения всех изменений структуры.

## API эндпоинты

### POST `/api/segs`

Создание нового сегмента.

**Запрос:**
- Body: `{ blockData: { _id: string, title: string }, order: number, zones: Array<string> }`

**Ответ:**
- 201: `{ message: string, data: Seg }`
- 400: `{ message: string, errors?: array }` - ошибка валидации или зоны уже принадлежат другим сегментам
- 404: `{ message: string }` - блок не найден
- 500: `{ message: string, error?: any }` - ошибка сервера

**Доступ:** Требует роль ADMIN

### GET `/api/segs`

Получение всех сегментов, отсортированных по порядку.

**Запрос:**
- Query параметры отсутствуют

**Ответ:**
- 200: `{ exists: boolean, message: string, data: Array<Seg> }`
- 500: `{ message: string, error?: any }` - ошибка сервера

**Доступ:** Требует роль ADMIN

### GET `/api/segs/:id`

Получение сегмента по идентификатору.

**Запрос:**
- Path параметры: `id` (MongoDB ObjectId)

**Ответ:**
- 200: `{ exists: boolean, message: string, data: Seg | null }`
- 400: `{ message: string, errors?: array }` - неверный формат ID
- 500: `{ message: string, error?: any }` - ошибка сервера

**Доступ:** Требует роль ADMIN

### GET `/api/segs/by-block/:blockId`

Получение всех сегментов блока, отсортированных по порядку.

**Запрос:**
- Path параметры: `blockId` (MongoDB ObjectId)

**Ответ:**
- 200: `{ exists: boolean, message: string, data: Array<Seg> }`
- 400: `{ message: string, errors?: array }` - неверный формат ID
- 500: `{ message: string, error?: any }` - ошибка сервера

**Доступ:** Требует роль ADMIN

### GET `/api/segs/:segId/zones`

Получение всех зон сегмента.

**Запрос:**
- Path параметры: `segId` (MongoDB ObjectId)

**Ответ:**
- 200: `{ exists: boolean, message: string, data: Array<Zone> }`
- 400: `{ message: string, errors?: array }` - неверный формат ID
- 500: `{ message: string, error?: any }` - ошибка сервера

**Доступ:** Требует роль ADMIN

### PUT `/api/segs/:id`

Обновление сегмента.

**Запрос:**
- Path параметры: `id` (MongoDB ObjectId)
- Body: `{ order?: number, zones?: Array<string> }` (все поля опциональны, но хотя бы одно должно быть указано)

**Ответ:**
- 200: `{ message: string, data: Seg }`
- 400: `{ message: string, errors?: array }` - ошибка валидации или зоны уже принадлежат другим сегментам
- 404: `{ message: string }` - сегмент не найден
- 500: `{ message: string, error?: any }` - ошибка сервера

**Доступ:** Требует роль ADMIN

**Примечание:** Зоны удаленные из сегмента теряют связь с сегментом (поле seg удаляется, sector = 0). Сектора зон не пересчитываются автоматически.

### DELETE `/api/segs/:id`

Удаление сегмента.

**Запрос:**
- Path параметры: `id` (MongoDB ObjectId)

**Ответ:**
- 200: `{ message: string, data: Seg }`
- 400: `{ message: string, errors?: array }` - неверный формат ID
- 404: `{ message: string }` - сегмент не найден
- 500: `{ message: string, error?: any }` - ошибка сервера

**Примечание:** При удалении сегмента все связанные зоны теряют связь с сегментом (поле seg удаляется, sector = 0). Сегмент также удаляется из массива segs блока.

**Доступ:** Требует роль ADMIN

### POST `/api/segs/upsert`

Массовое создание или обновление сегментов.

**Запрос:**
- Body: `Array<{ _id?: string, blockId: string, order: number, zones: Array<string> }>`

**Ответ:**
- 200: `{ message: string, data: { processedSegs: Array<Seg> } }`
- 400: `{ message: string, errors?: array }` - ошибка валидации
- 500: `{ message: string, error?: any }` - ошибка сервера

**Доступ:** Требует роль ADMIN

**Примечание:** Операция выполняется в рамках MongoDB транзакции для обеспечения целостности данных.

## Форматы данных

### Seg

```typescript
{
  _id: string;                    // MongoDB ObjectId
  block: string;                   // ObjectId блока
  blockData: {                     // Кэшированные данные блока
    _id: string;
    title: string;
  };
  sector: number;                  // Рассчитанный сектор (blockOrder * 1000 + segOrder)
  order: number;                   // Порядок в блоке (начинается с 1)
  zones: Array<{                   // Кэшированные данные зон
    _id: string;
    title: string;
  }>;
  createdAt: Date;                 // Дата создания
  updatedAt: Date;                 // Дата обновления
}
```

